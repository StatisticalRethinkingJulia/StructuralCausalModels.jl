var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"StatisticalRethinking\nCausal Inference in Statistics - a primer\nCause and Correlation in Biology\nSadeghi, K. (2011). Stable classes of graphs containing directed acyclic graphs.\nRichardson, T.S. and Spirtes, P. (2002).  Ancestral graph Markov models {Annals of Statistics}, 30(4), 962-1030.\nSeparators and Adjustment Sets in Causal Graphs: Complete Criteria and an Algorithmic Framework","category":"page"},{"location":"versions/#Versions","page":"Versions","title":"Versions","text":"","category":"section"},{"location":"versions/#.1.0","page":"Versions","title":"0.1.0","text":"","category":"section"},{"location":"versions/","page":"Versions","title":"Versions","text":"Version for initial commit to Julia's registry.\nIntroduction of basic functionality.\nNo support latent variables.","category":"page"},{"location":"acknowledgements/#Acknowledgements","page":"Acknowledgements","title":"Acknowledgements","text":"","category":"section"},{"location":"acknowledgements/","page":"Acknowledgements","title":"Acknowledgements","text":"Important links are:","category":"page"},{"location":"acknowledgements/","page":"Acknowledgements","title":"Acknowledgements","text":"Dagitty\nR dagitty package\nR ggm package","category":"page"},{"location":"acknowledgements/","page":"Acknowledgements","title":"Acknowledgements","text":"The latter (both the Giordini code and the Sadeghi code) has been used as the basis for the Julia implementations of e.g. shipley_test(), d_separation(), basis_set() and ancestral_graph().","category":"page"},{"location":"introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"StructuralCausalModels.jl (SCM) is a Julia package to analyse directed acyclic graphs (DAGs) as described in StatisticalRethinking, Causal Inference in Statistics and Cause and Correlation in Biology.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"My initial goal for this package is to have a way to apply SCM ideas to the examples in StatisticalRethinking.jl, i.e. a working version of basis_set(), d_separation(), pcor_test() and adjustment_sets().","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"All three above references are great introductions to the use of causal models to help in understanding confounding in statistical multiple regression models based on observational data. ","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"StructuralCausalModels.jl is part of the StatisticalRethinkingJulia eco system. The package, once registered, can be installed using ] add StructuralCausalModels.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Please report issues (or file a pull request) on Github if you find a problem.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Note: Version 0.1.0 of StructuralCausalModels.jl does not support latent variables.","category":"page"},{"location":"walkthrough/#Structural-Causal-Models","page":"Walkthrough","title":"Structural Causal Models","text":"","category":"section"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"To demonstrate the fuctionality in this package, setup of the 'marks' example from the ggm R package:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"using StructuralCausalModels\n\nProjDir = @__DIR__\ncd(ProjDir)\n\ndf = DataFrame!(CSV.File(scm_path(\"..\", \"data\", \"marks.csv\")));","category":"page"},{"location":"walkthrough/#DAG-directed-acyclic-graphs","page":"Walkthrough","title":"DAG - directed acyclic graphs","text":"","category":"section"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"DAG() accepts either an OrderedDict, an adjacency_matrix or a ggm/dagitty string. See the ancestral_graph section below for an example using an adjacency_matrix.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Below d_string holds a ggm DAG definition.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"d_string = \"DAG(\n    mechanics ~ vectors+algebra, \n    vectors ~ algebra, \n    statistics ~ algebra+analysis, \n    analysis ~ algebra)\"\n\ndag = DAG(\"marks\", d_string; df=df);\nshow(dag)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"The d_string can also contain a dagitty causal model.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"# fig2.6.dag <- dagitty(\"dag { {X V} -> U; S1 <- U; {Y V} -> W; S2 <- W}\")\ndag = DAG(\"fig_2_6\", \"dag {{X V} -> U; S1 <- U; {Y V} -> W; S2 <- W}\")","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"In the REPL show(dag) will display:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"DAG object:\n\nname = \"marks\"\nvars = [:mechanics, :vectors, :algebra, :statistics, :analysis]\n\nOrderedDict{Symbol,Union{Nothing, Array{Symbol,1}, Symbol}} with 4 entries:\n  :mechanics  => [:vectors, :algebra]\n  :vectors    => :algebra\n  :statistics => [:algebra, :analysis]\n  :analysis   => :algebra","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Internally, a DAG object will always contain an OrderedDict representation of the DAG. This representation is used in all functions. In the definition of the OrderedDict, read => as ~ in regression models or <- in causal models.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Optional display the DAG using GraphViz:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"fname = ProjDir * \"/marks.dot\"\nto_graphviz(dag, fname)\nSys.isapple() && run(`open -a GraphViz.app $(fname)`)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"The DAG pdf is here.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"In this example a DataFrame with observed values has been provided and the related covariance matrix will be computed and stored in the DAG object:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"display(dag.s)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"5×5 Named Array{Float64,2}\nRows ╲ Cols │  :mechanics     :vectors     :algebra    :analysis  :statistics\n────────────┼────────────────────────────────────────────────────────────────\n:mechanics  │     305.768      127.223      101.579      106.273      117.405\n:vectors    │     127.223      172.842      85.1573      94.6729       99.012\n:algebra    │     101.579      85.1573      112.886      112.113      121.871\n:analysis   │     106.273      94.6729      112.113       220.38      155.536\n:statistics │     117.405       99.012      121.871      155.536      297.755","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Additional DAG related functions are adjacency_matrix(), edge_matrix() and dag_vars().","category":"page"},{"location":"walkthrough/#Importing-from-and-exporting-to-[dagitty.net](http://www.dagitty.net/dags.html#),-dagitty-and-ggm-(both-are-R-packages)","page":"Walkthrough","title":"Importing from and exporting to dagitty.net, dagitty and ggm (both are R packages)","text":"","category":"section"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Importing is easiest implicitly using the functions from_dagitty() and from_ggm() while constructing a DAG object, as shown above.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"To export to dagitty.net, copy and paste the output from to_dagitty() into the Model code field on the dagitty.net web interface.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"For both R packages, copy the output from to_dagitty() or to_ggm() to R.","category":"page"},{"location":"walkthrough/#Adding-a-observations-DataFrame-or-a-covariance-matrix","page":"Walkthrough","title":"Adding a observations DataFrame or a covariance matrix","text":"","category":"section"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Use set_dag_df!() and set_dag_cov_matrix!() for this. Note that if a DataFrame is added a covariance matrix is computed.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Although this initial version of StructuralCausalModels does not support latent variables yet, by using the keyword argument force=true no check is performed if all vertices/variables in the causal diagram are present in the DataFrame or covariance matrix.","category":"page"},{"location":"walkthrough/#Directed-separation","page":"Walkthrough","title":"Directed separation","text":"","category":"section"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Given a causal graph dag, d_separation(dag, f, l, cond) determines if the vertices in set f are d-separated from the vertices in set l given the conditioning set cond.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Show several d_separation results for the marks model:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"f = [:statistics]; s = [:mechanics];\n\ne = d_separation(dag, f, s; cond=:algebra);\nprintln(\"d_separation($(dag.name), $f, $s; cond=:algebra) = $e\")\n\ne = d_separation(dag, f, s);\nprintln(\"d_separation($(dag.name), $f, $s) = $e\")\n\nprint(\"d_separation($(dag.name), [:statistics], [:mechanics, :analysis]; cond=[:algebra]) = \");\nprintln(d_separation(dag, [:statistics], [:mechanics, :analysis]; cond=[:algebra]))","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"will produce:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"d_separation(marks, [:statistics], [:mechanics]; cond=:algebra) = false\nd_separation(marks, [:statistics], [:mechanics]) = true\nd_separation(marks, [:statistics], [:mechanics, :analysis]: cond=[:algebra]) = false","category":"page"},{"location":"walkthrough/#Basis-set","page":"Walkthrough","title":"Basis set","text":"","category":"section"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"A minimal set of d_separation statements is called a basis_set.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"A basis_set is not necessarily unique but it is sufficient to predict the complete set of d_separation statements.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Compute the basis_set:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"bs = basis_set(dag)\ndisplay(bs)\n\nBasisSet[\n  vectors ∐ analysis | [:algebra]\n  vectors ∐ statistics | [:algebra, :analysis]\n  mechanics ∐ analysis | [:algebra, :vectors]\n  mechanics ∐ statistics | [:algebra, :vectors, :analysis]\n]","category":"page"},{"location":"walkthrough/#Adjustment-sets","page":"Walkthrough","title":"Adjustment sets","text":"","category":"section"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"The function  basis_set() provides a set of conditional independencies given the causal model. The conditioning set closes (\"blocks the flow of causal info\") all paths. The conditioning_set can be empty. It provides ways to test the chosen causal model given observational data.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"The function adjustment_sets() answers a related question, i.e. how to prevent confounding in multiple regression models assuming the chosen causal model is correct.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Setup the WaffleDivorce example from StatisticalRethinking:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"using StructuralCausalModels\n\nProjDir = @__DIR__\ncd(ProjDir) #do\n\ndf = DataFrame!(CSV.File(scm_path(\"..\", \"data\", \"WaffleDivorce.csv\"), delim=';');\ndf = DataFrame(\n  :s => df[:, :South],\n  :a => df[:, :MedianAgeMarriage],\n  :m => df[:, :Marriage],\n  :w => df[:, :WaffleHouses],\n  :d => df[:, :Divorce]\n);\n\nfname = scm_path(\"..\", \"examples\", \"SR\", \"SR6.4.3\", \"sr6.4.3.dot\")\nSys.isapple() && run(`open -a GraphViz.app $(fname)`)\n\nd = OrderedDict(\n  [:a, :m, :w] => :s,\n  :d => [:w, :m, :a],\n  :m => [:a]\n);\nu = []\n\ndag = DAG(\"sr6_4_3\", d, df);\nshow(dag)\n\nadjustmentsets = adjustment_sets(dag, :w, :d)\nprintln(\"Adjustment sets for open paths: $(openpaths)\\n\")\nadjustmentsets |> display\n\nAdjustment sets:\n2-element Array{Array{Symbol,1},1}:\n [:s]\n [:a, :m]","category":"page"},{"location":"walkthrough/#Shipley-test","page":"Walkthrough","title":"Shipley test","text":"","category":"section"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Perform the Shipley test:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"t = shipley_test(dag)\ndisplay(t)\n\n(ctest = 2.816854003338401, df = 8, pv = 0.9453198036802164)","category":"page"},{"location":"walkthrough/#Paths","page":"Walkthrough","title":"Paths","text":"","category":"section"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Adjustment_sets is based on several path manipulations and checks:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"allpaths  = all_paths(dag, :w, :d)\nprintln(\"All paths between :w and :d:\")\nallpaths |> display\nprintln()","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"for this DAG returns:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"4-element Array{Array{Symbol,1},1}:\n [:w, :s, :a, :d]\n [:w, :s, :a, :m, :d]\n [:w, :s, :m, :d]\n [:w, :s, :m, :a, :d]","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"backdoorpaths = backdoor_paths(dag, allpaths, :w)\nprintln(\"All backdoors between :w and :d:\")\nbackdoorpaths |> display\nprintln()\n\n4-element Array{Array{Symbol,1},1}:\n [:w, :s, :a, :d]\n [:w, :s, :a, :m, :d]\n [:w, :s, :m, :d]\n [:w, :s, :m, :a, :d]\n","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"println(\"Show path: $(allpaths[2])\")\nshow_dag_path(dag, allpaths[2]) |> display\nprintln()\n\n\":w ⇐ :s ⇒ :a ⇒ :m ⇒ :d\"","category":"page"},{"location":"walkthrough/#Ancestral-graph","page":"Walkthrough","title":"Ancestral graph","text":"","category":"section"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Setup an ancestral_graph example:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"using StructuralCausalModels, Test\n\nProjDir = @__DIR__\n\n#include(scm_path(\"test_methods\", \"test_ag.jl\"))\n\namat_data = transpose(reshape([\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,\n  0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,\n  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0\n], (16,16)));\n\nvars = [Symbol(\"n$i\") for i in 1:size(amat_data, 1)]\na = NamedArray(Int.(amat_data), (vars, vars), (\"Rows\", \"Cols\"));\n\ndag = DAG(\"ag_example\", a)\n\nm = [:n3, :n5, :n6, :n15, :n16];\nc = [:n4, :n7];\n\nfr = StructuralCausalModels.test_ag(a; m=m, c=c)\n\nfr1 = ancestral_graph(a; m=m, c=c)\n@test all(fr .== fr1)\n\nfr2 = StructuralCausalModels.test_ag(dag.a; m=m, c=c)\n@test all(fr .== fr2);\n\nprintln()\ndisplay(fr)\nprintln()","category":"page"},{"location":"","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"CurrentModule = StructuralCausalModels","category":"page"},{"location":"#StructuralCausalModels","page":"StructuralCausalModels API","title":"StructuralCausalModels","text":"","category":"section"},{"location":"","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"StructuralCausalModels","category":"page"},{"location":"#StructuralCausalModels.StructuralCausalModels","page":"StructuralCausalModels API","title":"StructuralCausalModels.StructuralCausalModels","text":"StructuralCausalModels\n\nStructuralCausalModels.jl provides functionality to analyse directed acyclic graph (DAG) based causal models as described in StatisticalRethinking, Causal Inference in Statistics and Cause and Correlation in Biology.\n\nMy initial goal for this package is to have a way to apply SCM ideas to the examples in the context of StatisticalRethinking, i.e. a working version of basis_set(), d_separation(), m_separation() and adjustment_sets().\n\nSCM can be used as an alias to StructuralCausalModels.\n\n\n\n\n\n","category":"module"},{"location":"#SCM","page":"StructuralCausalModels API","title":"SCM","text":"","category":"section"},{"location":"","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"SCM","category":"page"},{"location":"#StructuralCausalModels.SCM","page":"StructuralCausalModels API","title":"StructuralCausalModels.SCM","text":"SCM\n\nAlias for StructuralCausalModels\n\n\n\n\n\n","category":"module"},{"location":"#scm_path","page":"StructuralCausalModels API","title":"scm_path","text":"","category":"section"},{"location":"","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"scm_path(parts...)","category":"page"},{"location":"#StructuralCausalModels.scm_path-Tuple","page":"StructuralCausalModels API","title":"StructuralCausalModels.scm_path","text":"scm_path\n\nRelative path using the StructuralCausalModels.jl src/ directory.\n\nExample to get access to the data subdirectory\n\nscm_path(\"..\", \"data\")\n\nPart of the API, exported.\n\n\n\n\n\n","category":"method"},{"location":"#DAG","page":"StructuralCausalModels API","title":"DAG","text":"","category":"section"},{"location":"","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"DAG(name::AbstractString, model::ModelDefinition; df::DataFrameOrNothing=nothing)","category":"page"},{"location":"#StructuralCausalModels.DAG-Tuple{AbstractString, Union{AbstractString, NamedArray, OrderedDict}}","page":"StructuralCausalModels API","title":"StructuralCausalModels.DAG","text":"DAG\n\nDirected acyclic graph constructor\n\nDAG(name, model; df)\n\n\nRequired arguments\n\n* `name::AbstractString`               : Name for the DAG object\n* `d::ModelDefinition`                 : DAG definition\n\nwhere\n\nModelDefinition = Union{OrderedDict, AbstractString, NamedArray}\n\nSee the extended help for a usage example.\n\nKeyword arguments\n\n* `df::DataFrame`                      : DataFrame with observations\n\nReturns\n\n* `dag::DAG`                           : Boolean result of test\n\nExtended help\n\nIn the definition of the OrderedDict, read => as ~ in regression models or <- in causal models, e.g.:\n\nd = OrderedDict(\n  :u => [:x, :v],\n  :s1 => [:u],\n  :w => [:v, :y],\n  :s2 => [:w]\n);\ndag = DAG(\"my_name\", d)\n\nComing from R's dagitty:\n\namat <- dagitty(\"dag { {X V} -> U; S1 <- U; {Y V} -> W; S2 <- W}”)\n\ndag = DAG(\"my_name\", \"dag { {X V} -> U; S1 <- U; {Y V} -> W; S2 <- W}”)\ndisplay(dag) # Show the DAG\n\nComing from R's ggm:\n\namat <- DAG(U~X+V, S1~U, W~V+Y, S2~W, order=FALSE)\n\ndag = DAG(\"my_name\", \"DAG(U~X+V, S1~U, W~V+Y, S2~W”)\ndisplay(dag) # Show the DAG\n\nAcknowledgements\n\nOriginal author:                       Giovanni M. Marchetti\n\nTranslated to Julia:                   Rob J Goedman\n\nLicense\n\nThe R package ggm is licensed under License: GPL-2.\n\nThe Julia translation is licenced under: MIT.\n\nPart of API, exported.\n\n\n\n\n\n","category":"method"},{"location":"#d_separation","page":"StructuralCausalModels API","title":"d_separation","text":"","category":"section"},{"location":"","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"d_separation(d::DAG, f::SymbolList, s::SymbolList; c::SymbolListOrNothing, debug=false)","category":"page"},{"location":"#StructuralCausalModels.d_separation-Tuple{DAG, Union{Symbol, Vector{Symbol}}, Union{Symbol, Vector{Symbol}}}","page":"StructuralCausalModels API","title":"StructuralCausalModels.d_separation","text":"d_separation\n\nd_separation(d, f, s; c, debug)\n\n\nComputes the d_separation between 2 sets of nodes conditioned on a third set.\n\nRequired arguments\n\nd_separation(\n* `d::DAG`                             : DAG\n* `f::SymbolList`                      : First set\n*  s::SymbolList`                      : Second set\n)\n\nKeyword arguments\n\n* `c::SymbolListOrNothing=nothing`     : Conditioning set\n* `debug=false`                        : Trace execution\n\nReturns\n\n* `res::Bool`                          : Boolean result of test\n\nExtended help\n\nExample\n\nd_separation between mechanics and statistics, conditioning on algebra\n\nusing StructuralCausalModels, CSV\n\ndf = DataFrame!(CSV.File(scm_path(\"..\", \"data\", \"marks.csv\"));\n\nd = OrderedDict(\n  :mechanics => [:vectors, :algebra],\n  :vectors => [:algebra],\n  :analysis => [:algebra],\n  :statistics => [:algebra, :analysis]\n);\n\ndag = DAG(\"marks\", d, df);\nd_separation(marks, [:statistics], [:mechanics]; c=[:algebra]))\n\nAcknowledgements\n\nOriginal author:                       Giovanni M. Marchetti\n\nTranslated to Julia:                   Rob J Goedman\n\nLicense\n\nThe R package ggm is licensed under License: GPL-2.\n\nThe Julia translation is licenced under: MIT.\n\nPart of the API, exported.\n\n\n\n\n\n","category":"method"},{"location":"#m_separation","page":"StructuralCausalModels API","title":"m_separation","text":"","category":"section"},{"location":"","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"m_separation(d::DAG, f::SymbolList, s::SymbolList; c::SymbolListOrNothing, debug=false)","category":"page"},{"location":"#StructuralCausalModels.m_separation-Tuple{DAG, Union{Symbol, Vector{Symbol}}, Union{Symbol, Vector{Symbol}}}","page":"StructuralCausalModels API","title":"StructuralCausalModels.m_separation","text":"m_separation\n\nm_separation(d, f, s; c, debug)\n\n\nComputes the m_separation between 2 sets of nodes conditioned on a third set.\n\nRequired arguments\n\nm_separation(\n* `d::DAG`                             : DAG\n* `f::SymbolList`                      : First vertex or set\n*  s::SymbolList`                      : Second vertex or set\n)\n\nKeyword arguments\n\n* `c::SymbolListOrNothing=nothing`     : Conditioning set\n* `debug=false`                        : Trace execution\n\nReturns\n\n* `res::Bool`                          : Boolean result of test\n\nExtended help\n\nExample\n\nm_separation between mechanics and statistics, conditioning on algebra\n\nusing StructuralCausalModels, CSV\n\ndf = DataFrame!(CSV.File(scm_path(\"..\", \"data\", \"marks.csv\"));\n\nd = OrderedDict(\n  :mechanics => [:vectors, :algebra],\n  :vectors => [:algebra],\n  :analysis => [:algebra],\n  :statistics => [:algebra, :analysis]\n);\n\ndag = DAG(\"marks\", d, df);\nm_separation(marks, [:statistics], [:mechanics]; c=[:algebra]))\n\nAcknowledgements\n\nOriginal author:                       Giovanni M. Marchetti\n\nTranslated to Julia:                   Rob J Goedman\n\nLicense\n\nThe R package ggm is licensed under License: GPL-2.\n\nThe Julia translation is licenced under: MIT.\n\nPart of the API, exported.\n\n\n\n\n\n","category":"method"},{"location":"#shipley_test","page":"StructuralCausalModels API","title":"shipley_test","text":"","category":"section"},{"location":"","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"shipley_test(d::DAG)","category":"page"},{"location":"#StructuralCausalModels.shipley_test-Tuple{DAG}","page":"StructuralCausalModels API","title":"StructuralCausalModels.shipley_test","text":"shipley_test\n\nshipley_test(d)\n\n\nTest of all independencies implied by a given DAG\n\nComputes a simultaneous test of all independence relationships implied by a given Gaussian model defined according to a directed acyclic graph, based on the sample covariance matrix.\n\nThe test statistic is C = -2 sum(ln(pj)) where pj are the p-values of tests of conditional independence in the basis set computed by basiSet(A). The p-values are independent uniform variables on (0,1) and the statistic has exactly a chi square distribution on 2k degrees of freedom where k is the number of elements of the basis set.  Shipley (2002) calls this test Fisher's C test.\n\nMethod\n\nshipley_test(;\n* `d::Dag`                             : Directed acyclic graph\n)\n\nReturns\n\n* `res::NamedTuple`                    : (ctest=..., dof=..., pval=...)\n\nwhere:\n\nctest: Test statistic C   dof:   Degrees of freedom.   pval:  The P-value of the test, assuming a two-sided alternative.\n\nExtended help\n\nExample\n\nShipley_test for the mathematics marks data\n\nusing StructuralCausalModels, RData\n\nobjs = RData.load(scm_path(\"..\", \"data\", \"marks.rda\");\nmarks_df = objs[\"marks\"]\n\nd = OrderedDict(\n  :mechanics => [:vectors, :algebra],\n  :vectors => [:algebra],\n  :statistics => [:algebra, :analysis],\n  :analysis => [:algebra]\n);\ndag = Dag(d; df=df)\nshipley_test(dag)\n\nSee also\n\n?Dag\n?basis_set\n?pcor_test\n\nAcknowledgements\n\nOriginal author:                       Giovanni M. Marchetti\n\nTranslated to Julia:                   Rob J Goedman\n\nReferences\n\nShipley, B. (2000). A new inferential test for path models based on directed acyclic graphs. Structural Equation Modeling, 7(2), 206–218.\n\nLicence\n\nThe R package ggm is licensed under License: GPL-2.\n\nThe Julia translation is licenced under: MIT.\n\nPart of the api, exported.\n\n\n\n\n\n","category":"method"},{"location":"#basis_set","page":"StructuralCausalModels API","title":"basis_set","text":"","category":"section"},{"location":"","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"basis_set(dag::DAG)","category":"page"},{"location":"#StructuralCausalModels.basis_set-Tuple{DAG}","page":"StructuralCausalModels API","title":"StructuralCausalModels.basis_set","text":"basis_set\n\nDetermine basis_set\n\nbasis_set(dag; debug)\n\n\nPart of API, exported.\n\n\n\n\n\n","category":"method"},{"location":"#ancestral_graph","page":"StructuralCausalModels API","title":"ancestral_graph","text":"","category":"section"},{"location":"","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"ancestral_graph(d::DAG; m=Symbol[], c=Symbol[])","category":"page"},{"location":"#StructuralCausalModels.ancestral_graph-Tuple{DAG}","page":"StructuralCausalModels API","title":"StructuralCausalModels.ancestral_graph","text":"ancestral_graph\n\nancestral_graph(d; m, c)\n\n\nAncestral graphs after marginalization and conditioning.\n\nRequired arguments\n\n* `d::DAG`                             : DAG onject\n\nOptional arguments\n\n* `m::Vector{Symbol}`                  : Nodes in DAG that are marginalized\n* `c::Vector{Symbol})`                 : Nodes in DAG there are conditioned on\n\nReturns\n\n* `ag::NamedArray`                     : Ancestral graph remaining\n\n\n\n\n\n","category":"method"},{"location":"#ribbbon_graph","page":"StructuralCausalModels API","title":"ribbbon_graph","text":"","category":"section"},{"location":"","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"ribbon_graph(d::DAG; m=Symbol[], c=Symbol[])","category":"page"},{"location":"#StructuralCausalModels.ribbon_graph-Tuple{DAG}","page":"StructuralCausalModels API","title":"StructuralCausalModels.ribbon_graph","text":"ribbon_graph\n\nribbon_graph(d; m, c)\n\n\nRibbon graphs after marginalization and conditioning.\n\nRequired arguments\n\n* `d::DAG`                             : DAG onject\n\nOptional arguments\n\n* `m::Vector{Symbol}`                  : Nodes in DAG that are marginalized\n* `c::Vector{Symbol})`                 : Nodes in DAG there are conditioned on\n\nReturns\n\n* `rg::NamedArray`                     : Ribbon graph remaining\n\n\n\n\n\n","category":"method"},{"location":"#adjustment_sets","page":"StructuralCausalModels API","title":"adjustment_sets","text":"","category":"section"},{"location":"","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"adjustment_sets(d::DAG, f::Symbol, l::Symbol; debug=false)","category":"page"},{"location":"#StructuralCausalModels.adjustment_sets-Tuple{DAG, Symbol, Symbol}","page":"StructuralCausalModels API","title":"StructuralCausalModels.adjustment_sets","text":"adjustment_sets\n\nadjustment_sets(dag, f, l; debug)\n\n\nComputes the covariance adjustment vertex set. \n\nRequired arguments\n\n* `dag::DAG`                           : DAG\n* `f::Symbol`                          : Start variable\n* `l::Symbol`                          : End variable\n\nOptional arguments\n\n* `debug::Bool`                        : Show debug trace\n\nReturns\n\n* `adjustmentsets=Vector{Symbol}[]`    : Array of adjustment sets\n\nExtended help\n\nAcknowledgements\n\nOriginal author                        : Rob J Goedman\n\nLicence\n\nLicenced under: MIT.\n\nPart of the api, exported.\n\n\n\n\n\n","category":"method"},{"location":"#paths","page":"StructuralCausalModels API","title":"paths","text":"","category":"section"},{"location":"","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"all_paths(d::DAG, f::Symbol, l::Symbol)\nbackdoor_paths(d::DAG, paths::Vector{Vector{Symbol}}, f::Symbol)","category":"page"},{"location":"#StructuralCausalModels.all_paths-Tuple{DAG, Symbol, Symbol}","page":"StructuralCausalModels API","title":"StructuralCausalModels.all_paths","text":"all_edges\n\nall_paths(d, f, l; debug)\n\n\nPart of the API, exported.\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.backdoor_paths-Tuple{DAG, Vector{Vector{Symbol}}, Symbol}","page":"StructuralCausalModels API","title":"StructuralCausalModels.backdoor_paths","text":"backdoor_paths\n\nbackdoor_paths(d, paths, f)\n\n\nInternal.\n\n\n\n\n\n","category":"method"},{"location":"#Support_functions","page":"StructuralCausalModels API","title":"Support_functions","text":"","category":"section"},{"location":"","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"adjacency_matrix(d::OrderedDict)\nadjacency_matrix(e::NamedArray)\nadjacency_matrix_to_dict(ea::NamedArray)\nancester_graph(e::NamedArray)\nancestral_graph(a::NamedArray{Int, 2}; m=Symbol[], c=Symbol[])\ncheck_open(d::DAG, path::Vector{Symbol}, conditioning_set::SymbolList; debug=false)\nDAG\ndag_show(io::IO, d::DAG)\ndag_vars(d::OrderedDict)\nedge_matrix(d::OrderedDict)\nedge_matrix(a::NamedArray, inv=false)\nindicator_matrix(e::NamedArray)\ninduced_covariance_graph(d::DAG, sel::Vector{Symbol}, cond::SymbolList; debug=false)\nnode_edges(p::Path, s::Symbol, l::Symbol)\nopen_paths(d::DAG, paths::Vector{Vector{Symbol}}, cond::Vector{Symbol};debug=false)\npcor(d::DAG, u::SymbolList)\npcor_test(d::DAG, u::SymbolList, q, n)\nribbon_graph(a::NamedArray{Int, 2}; m=Symbol[], c=Symbol[])\nsym_in_all_paths(paths, sym)\nsyms_in_paths(paths, f, l)\ntopological_order(a::NamedArray)\ntopological_sort(a::NamedArray)\ntopological_sort(dag::DAG)\ntopological_sort!(dag::DAG)\ntransitive_closure(a::NamedArray)\nset_dag_df!(d::DAG, df::DataFrameOrNothing; force=false)\nset_dag_cov_matrix!(d::DAG, cm::NamedArrayOrNothing; force=false)\nundirected_matrix(d::DAG)","category":"page"},{"location":"#StructuralCausalModels.adjacency_matrix-Tuple{OrderedDict}","page":"StructuralCausalModels API","title":"StructuralCausalModels.adjacency_matrix","text":"adjacency_matrix\n\nadjacency_matrix(d)\n\n\nPart of the API, exported\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.adjacency_matrix-Tuple{NamedArray}","page":"StructuralCausalModels API","title":"StructuralCausalModels.adjacency_matrix","text":"adjacency_matrix\n\nadjacency_matrix(e)\n\n\nPart of the API, exported\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.adjacency_matrix_to_dict-Tuple{NamedArray}","page":"StructuralCausalModels API","title":"StructuralCausalModels.adjacency_matrix_to_dict","text":"adjacency_matrix_to_dict\n\nadjacency_matrix_to_dict(a)\n\n\nPart of the API, exported.\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.ancester_graph-Tuple{NamedArray}","page":"StructuralCausalModels API","title":"StructuralCausalModels.ancester_graph","text":"ancestor_graph\n\nancester_graph(e)\n\n\nInternal\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.ancestral_graph-Tuple{NamedMatrix{Int64}}","page":"StructuralCausalModels API","title":"StructuralCausalModels.ancestral_graph","text":"ancestral_graph\n\nancestral_graph(amat; m, c)\n\n\nAncestral graphs after marginalization and conditioning.\n\nRequired arguments\n\n* `amat::NamedArray{Int, 2}`           : Adjacency matrix of a DAG\n\nOptional arguments\n\n* `m::Vector{Symbol}`                  : Nodes in DAG that are marginalized\n* `c::Vector{Symbol})`                 : Nodes in DAG there are conditioned on\n\nReturns\n\n* `ag::NamedArray`                     : Ancestral graph remaining\n\nExtended help\n\nExample\n\nAdjacency matrix used for testing in ggm\n\namat_data = transpose(reshape([\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,\n  0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,\n  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0\n], (16,16)));\n\nvars = [Symbol(\"n\\$i\") for i in 1:size(amat_data, 1)]\namat = NamedArray(Int.(amat_data), (vars, vars), (\"Rows\", \"Cols\"));\nm = [:n3, :n5, :n6, :n15, :n16];\nc = [:n4, :n7];\n\nag = ancestral_graph(amat; m = m, c = c)\n\nAcknowledgements\n\nOriginal author:                       Kayvan Sadeghi\n\nTranslated to Julia:                   Rob J Goedman\n\nReferences\n\nSadeghi, K. (2011). Stable classes of graphs containing directed acyclic graphs.\n\nRichardson, T.S. and Spirtes, P. (2002).  Ancestral graph Markov models {Annals of Statistics}, 30(4), 962-1030.\n\nLicence\n\nThe R package ggm is licensed under License: GPL-2.\n\nThe Julia translation is licenced under: MIT.\n\nPart of the api, exported.\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.check_open-Tuple{DAG, Vector{Symbol}, Union{Symbol, Vector{Symbol}}}","page":"StructuralCausalModels API","title":"StructuralCausalModels.check_open","text":"check_open\n\ncheck_open(d, path, conditioning_set; debug)\n\n\nInternal.\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.DAG","page":"StructuralCausalModels API","title":"StructuralCausalModels.DAG","text":"DAG\n\nDirected acyclic graph struct\n\nStruct\n\nDAG(\n* `name::AbstractString`                    : Name for the DAG object\n* `d::OrderedDictOrNothing`                 : DAG definition as an OrderedDict\n* `a::NamedArrayOrNothing`                  : Adjacency matrix\n* `e::NamedArrayOrNothing`                  : Edge matrix\n* `s::NamedArrayOrNothing`                  : Covariance matrix\n* `df::DataFrameOrNothing`                  : Variable observations\n* `vars::Vector{Symbol}`                    : Names of variables in DAG\n)\n\nPart of API, exported.\n\n\n\n\n\n","category":"type"},{"location":"#StructuralCausalModels.dag_show-Tuple{IO, DAG}","page":"StructuralCausalModels API","title":"StructuralCausalModels.dag_show","text":"dag_show\n\ndag_show(io, d)\n\n\nInternal\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.dag_vars-Tuple{OrderedDict}","page":"StructuralCausalModels API","title":"StructuralCausalModels.dag_vars","text":"dag_vars\n\ndag_vars(d)\n\n\nPart of the API, exported\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.edge_matrix-Tuple{OrderedDict}","page":"StructuralCausalModels API","title":"StructuralCausalModels.edge_matrix","text":"edge_matrix\n\nedge_matrix(d)\n\n\nPart of the API, exported\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.edge_matrix","page":"StructuralCausalModels API","title":"StructuralCausalModels.edge_matrix","text":"edge_matrix\n\nedge_matrix(a)\nedge_matrix(a, inv)\n\n\nPart of the API, exported\n\n\n\n\n\n","category":"function"},{"location":"#StructuralCausalModels.indicator_matrix-Tuple{NamedArray}","page":"StructuralCausalModels API","title":"StructuralCausalModels.indicator_matrix","text":"indicator_matrix\n\nindicator_matrix(e)\n\n\nInternal\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.induced_covariance_graph-Tuple{DAG, Vector{Symbol}, Union{Symbol, Vector{Symbol}}}","page":"StructuralCausalModels API","title":"StructuralCausalModels.induced_covariance_graph","text":"induced_covariance_graph\n\ninduced_covariance_graph(d, sel, c; debug)\n\n\nInternal\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.node_edges-Tuple{Path, Symbol, Symbol}","page":"StructuralCausalModels API","title":"StructuralCausalModels.node_edges","text":"node_edges\n\nnode_edges(p, s, l; debug)\n\n\nInternal.\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.open_paths-Tuple{DAG, Vector{Vector{Symbol}}, Vector{Symbol}}","page":"StructuralCausalModels API","title":"StructuralCausalModels.open_paths","text":"open_paths\n\nopen_paths(d, paths, cond; debug)\n\n\nInternal.\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.pcor-Tuple{DAG, Union{Symbol, Vector{Symbol}}}","page":"StructuralCausalModels API","title":"StructuralCausalModels.pcor","text":"pcor\n\npcor(d, u)\n\n\nComputes the partial correlation between two variables given a set of other variables.\n\nMethod\n\npcor(;\n* `d::DAG`                             : DAG object\n* `u::Vector{Symbol}`                  : Variables used to compute correlation\n)\n\nwhere:\n\nu[1], u[2]: Variables used to compute correlation between, remaining variables   are the conditioning set\n\nReturns\n\n* `res::Float64`                       : Correlation between u[1] and u[2]\n\nExtended help\n\nExample\n\nCorrelation between vectors and algebra, conditioning on analysis and statistics\n\nusing StructuralCausalModels, CSV\n\ndf = DataFrame!(CSV.File(scm_path(\"..\", \"data\", \"marks.csv\"));\nS = cov(Array(df))\n\nu = [2, 3, 4, 5]\npcor(u, S)\nu = [:vectors, :algebra, :statistics, :analysis]\n\nAcknowledgements\n\nOriginal author:                       Giovanni M. Marchetti\n\nTranslated to Julia:                   Rob J Goedman\n\nLicense\n\nThe R package ggm is licensed under License: GPL-2.\n\nThe Julia translation is licenced under: MIT.\n\nPart of the api, not exported.\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.pcor_test-Tuple{DAG, Union{Symbol, Vector{Symbol}}, Any, Any}","page":"StructuralCausalModels API","title":"StructuralCausalModels.pcor_test","text":"pcor_test\n\npcor_test(d, u, q, n)\n\n\nComputes the partial correlation between two variables given a set of other variables.\n\nMethod\n\npcor_test(;\n* `u::Vector{Symbol}`                  : Variables used to compute correlation\n* `q::Int`                             : Number of variables in conditioning set\n* `n::Int`                             : Number of observations\n* `S::Matrix`                          : Sample covariance matrix\n)\n\nwhere:\n\nu[1], u[2]: Variables used to compute correlation between, remaining variables   are the conditioning set\n\nReturns\n\n* `res::Float64`                       : Correlation between u[1] and u[2]\n\nExtended help\n\nAcknowledgements\n\nOriginal author:                       Giovanni M. Marchetti\n\nTranslated to Julia:                   Rob J Goedman\n\nLicense\n\nThe R package ggm is licensed under License: GPL-2.\n\nThe Julia translation is licenced under: MIT.\n\nPart of the api, not exported.\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.ribbon_graph-Tuple{NamedMatrix{Int64}}","page":"StructuralCausalModels API","title":"StructuralCausalModels.ribbon_graph","text":"ribbon_graph\n\nribbon_graph(amat; m, c)\n\n\nRibbon graphs after marginalization and conditioning.\n\nRequired arguments\n\n* `amat::NamedArray{Int, 2}`           : Adjacency matrix of a DAG\n\nOptional arguments\n\n* `m::Vector{Symbol}`                  : Nodes in DAG that are marginalized\n* `c::Vector{Symbol})`                 : Nodes in DAG there are conditioned on\n\nReturns\n\n* `rg::NamedArray`                     : Ribbon graph remaining\n\nExtended help\n\nExample\n\nAdjacency matrix used for testing in ggm\n\namat_data = transpose(reshape([\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,\n  0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,\n  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0\n], (16,16)));\n\nvars = [Symbol(\"n\\$i\") for i in 1:size(amat_data, 1)]\namat = NamedArray(Int.(amat_data), (vars, vars), (\"Rows\", \"Cols\"));\nm = [:n3, :n5, :n6, :n15, :n16];\nc = [:n4, :n7];\n\nrg = ribbon_graph(amat; m = m, c = c)\n\nAcknowledgements\n\nOriginal author:                       Kayvan Sadeghi\n\nTranslated to Julia:                   Rob J Goedman\n\nReferences\n\nSadeghi, K. (2011). Stable classes of graphs containing directed acyclic graphs.\n\nRichardson, T.S. and Spirtes, P. (2002).  Ancestral graph Markov models {Annals of Statistics}, 30(4), 962-1030.\n\nSadeghi, K. and Lauritzen, S.L. (2011). Markov properties for loopless mixed graphs.\n\nLicence\n\nThe R package ggm is licensed under License: GPL-2.\n\nThe Julia translation is licenced under: MIT.\n\nPart of the api, exported.\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.sym_in_all_paths-Tuple{Any, Any}","page":"StructuralCausalModels API","title":"StructuralCausalModels.sym_in_all_paths","text":"syms_in_all_paths\n\nCheck if a vertex is part of all paths.\n\nsym_in_all_paths(paths, sym)\n\n\nPart of the API, Exported\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.syms_in_paths-Tuple{Any, Any, Any}","page":"StructuralCausalModels API","title":"StructuralCausalModels.syms_in_paths","text":"syms_in_paths\n\nCollect vertices in all paths.\n\nsyms_in_paths(paths, f, l)\n\n\nPart of the API, Exported\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.topological_order-Tuple{NamedArray}","page":"StructuralCausalModels API","title":"StructuralCausalModels.topological_order","text":"topological_order\n\ntopological_order(a)\n\n\nPart of the API, exported\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.topological_sort-Tuple{NamedArray}","page":"StructuralCausalModels API","title":"StructuralCausalModels.topological_sort","text":"topological_sort\n\ntopological_sort(a)\n\n\nPart of the API, exported\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.topological_sort-Tuple{DAG}","page":"StructuralCausalModels API","title":"StructuralCausalModels.topological_sort","text":"topological_sort\n\ntopological_sort(dag)\n\n\nPart of the API, exported\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.topological_sort!-Tuple{DAG}","page":"StructuralCausalModels API","title":"StructuralCausalModels.topological_sort!","text":"topological_sort!\n\ntopological_sort!(dag)\n\n\nPart of the API, exported\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.transitive_closure-Tuple{NamedArray}","page":"StructuralCausalModels API","title":"StructuralCausalModels.transitive_closure","text":"transitive_closure\n\ntransitive_closure(a)\n\n\nInternal\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.set_dag_df!-Tuple{DAG, Union{Nothing, DataFrame}}","page":"StructuralCausalModels API","title":"StructuralCausalModels.set_dag_df!","text":"set_dag_df!\n\nSet or update Dataframe associated to DAG\n\nset_dag_df!(d, df; force)\n\n\nRequired arguments\n\n* `d::DAG`                                  : Previously defined DAG object \n* `df::DataFrameOrNothing`                  : DataFrame associated with DAG\n)\n\nOptional arguments\n\n* `force=false`                             : Force assignment of df \n)\n\nThe force = true option can be used if the DAG involves unobserved nodes.\n\nPart of API, exported.\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.set_dag_cov_matrix!-Tuple{DAG, Union{Nothing, NamedArray}}","page":"StructuralCausalModels API","title":"StructuralCausalModels.set_dag_cov_matrix!","text":"set_dag_cov_matrix!\n\nSet or update the covariance matrix associated to DAG\n\nset_dag_cov_matrix!(d, cm; force)\n\n\nRequired arguments\n\n* `d::DAG`                                  : Previously defined DAG object \n* `cm::NamedArrayOrNothing`                 : Covariance matrix in NamedArray format\n)\n\nOptional arguments\n\n* `force=false`                             : Force assignment of df \n)\n\nThe force = true option can be used if the DAG involves unobserved nodes.\n\nPart of API, exported.\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.undirected_matrix-Tuple{DAG}","page":"StructuralCausalModels API","title":"StructuralCausalModels.undirected_matrix","text":"undirected_matrix\n\nundirected_matrix(d)\n\n\nInternal\n\n\n\n\n\n","category":"method"}]
}
